//  $Id: plf2xml.cc,v 1.2 2000/07/13 20:28:48 grumbel Exp $
//
//  Pingus - A free Lemmings clone
//  Copyright (C) 2000 Ingo Ruhnke <grumbel@gmx.de>
//
//  This program is free software; you can redistribute it and/or
//  modify it under the terms of the GNU General Public License
//  as published by the Free Software Foundation; either version 2
//  of the License, or (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

#include <string>
#include <cstdio>

#include "../PingusError.hh"
#include "../PLF.hh"
#include "../PSMParser.hh"
#include "plf2xml.hh"

void write_footer(PLF* plf)
{
  puts("\n</pingus-level>");
}

void write_header(PLF* plf)
{
  puts("<?xml version=\"1.0\"?>\n"
       "<!-- Generated by plf2xml -->\n"
       "<pingus-level>\n");
}

void write_resdesc(ResDescriptor resdesc)
{
  printf("    <resource type=\"datafile\">\n"
	 "      <resource-file>%s</resource-file>\n"
	 "      <resource-ident>%s</resource-ident>\n"
	 "    </resource>\n",
	 resdesc.datafile.c_str(),
	 resdesc.res_name.c_str());
}

void
write_global(PLF* plf)
{
  std::cout  << "<global>\n"
	     << "  <author>" << plf->get_author() << "</author>\n"
	     << "  <levelname>" << plf->get_levelname() << "</levelname>\n"
	     << "  <description lang=\"en\">"
	     << plf->get_description()
	     << "</description>\n"
	     << " <number-of-pingus>" << plf->get_pingus() << "</number-of-pingus>\n"
	     << " <number-to-save>" << plf->get_number_to_save() << "</number-to-save>\n"
	     << "</global>\n"
	     << std::endl;
}

void
write_startpos(PLF* plf)
{
  std::cout << "<start>\n"
	    << "  <position>\n"
	    << "    <x-pos>" << plf->get_startx() << "</x-pos>\n"
	    << "    <y-pos>" << plf->get_starty() << "</y-pos>\n"
	    << "  </position>\n"
	    << "</start>\n" << std::endl;
}

void
write_actions(PLF* plf)
{
  vector<button_data> buttons = plf->get_buttons();
  
  std::cout << "<action-list>\n";
  for (vector<button_data>::iterator i = buttons.begin(); 
       i != buttons.end(); 
       i++)
    {
      std::cout << "  <action type=\"" << i->name << "\">" << i->number_of << "</action>" << std::endl;
    }
  std::cout << "</action-list>\n\n";
}

void
write_position(int x_pos, int y_pos, int z_pos)
{
  std::cout << "    <position>\n"
	    << "      <x-pos>" << x_pos << "</x-pos>\n"
	    << "      <y-pos>" << y_pos << "</y-pos>\n"
	    << "      <z-pos>" << z_pos << "</z-pos>\n"
	    << "    </position>\n";
}

void
write_position(int x_pos, int y_pos)
{
  std::cout << "    <position>\n"
	    << "      <x-pos>" << x_pos << "</x-pos>\n"
	    << "      <y-pos>" << y_pos << "</y-pos>\n"
	    << "    </position>\n";
}

void
write_direction(entrance_data::Direction dir)
{
  switch (dir)
    {
    case entrance_data::LEFT:
      std::cout << "    <direction>left</direction>\n" << std::endl;
      break;
    case entrance_data::RIGHT:
      std::cout << "    <direction>right</direction>\n" << std::endl;
      break;
    case entrance_data::MISC:
      std::cout << "    <direction>misc</direction>\n" << std::endl;
      break;
    }
}

void 
write_entrances(PLF* plf)
{
  vector<entrance_data> objects = plf->get_entrance();
  
  for (vector<entrance_data>::iterator i = objects.begin(); 
       i != objects.end(); 
       i++)
    {
      std::cout << "<entrance>\n"
		<< "  <type>" << i->type << "</type>\n"
		<< "  <release-rate>" << i->release_rate << "</release-rate>\n";
      write_direction(i->direction);
      write_position(i->x_pos, i->y_pos, i->z_pos);
      
      std::cout << "</entrance>\n\n";
    }
}

void
write_exits(PLF* plf)
{
  vector<exit_data> exits = plf->get_exit();
  
  for (vector<exit_data>::iterator i = exits.begin(); 
       i != exits.end(); 
       i++)
    {
      std::cout << "<exit>\n"
		<< "  <image>\n";
      
      write_resdesc(i->desc);

      std::cout << "  </image>\n";
      write_position(i->x_pos, i->y_pos, i->z_pos);
      std::cout << "</exit>\n\n";
    }
}

void
write_hotspots(PLF* plf)
{
  vector<hotspot_data> objects = plf->get_hotspot();
  
  for (vector<hotspot_data>::iterator i = objects.begin(); 
       i != objects.end(); 
       i++)
    {
      std::cout << "<hotspot>\n"
		<< "  <image>\n";
      write_resdesc(i->desc);
      std::cout << "  </image>\n";
      write_position(i->x_pos, i->y_pos, i->z_pos);
      std::cout << "</hotspot>\n\n";
    }
}

void
write_traps(PLF* plf)
{
  vector<trap_data> objects = plf->get_traps();
  
  for (vector<trap_data>::iterator i = objects.begin(); 
       i != objects.end(); 
       i++)
    {
      std::cout << "<trap>\n"
		<< "  <name>" << i->name << "</name>\n";
      write_position(i->x_pos, i->y_pos, i->z_pos);
      std::cout << "</trap>\n\n";
    }
}


void
write_liquid(PLF* plf)
{
  vector<liquid_data> objects = plf->get_liquids();
  
  for (vector<liquid_data>::iterator i = objects.begin(); 
       i != objects.end(); 
       i++)
    {
      std::cout << "<liquid>\n"
		<< "  <image>\n";
      write_resdesc(i->desc);
      std::cout << "  </image>\n";
      write_position(i->x_pos, i->y_pos, i->z_pos);
      std::cout << "  <width>" << i->width << "</width>" << std::endl;
      std::cout << "</liquid>\n\n";
    }
}

void
write_groundpieces(PSMParser* psm)
{
  vector<surface_data> objects = psm->get_surfaces();
  
  std::cout << "<groundpiece-list>" << std::endl; 
  for (vector<surface_data>::iterator i = objects.begin(); 
       i != objects.end(); 
       i++)
    {
      std::cout << "  <spot type=\"" << i->type_str << "\">\n";
      write_resdesc(i->res_desc);
      write_position(i->x_pos, i->y_pos);
      std::cout << "  </spot>\n\n";
    }
  std::cout << "</groundpiece-list>" << std::endl;
}

void
write_background(PLF* plf)
{
  background_data data = plf->get_bg();

  printf("<background>\n"
	 "  <image>\n");
  write_resdesc(data.desc);
  printf("  </image>\n"
	 "</background>\n\n");
}

int 
main(int argc, char* argv[])
{
  if (argc != 2)
    {
      puts("Usage: plf2xml FILE");
      exit(0);
    }
  else
    {
      try {
	PLF* plf;
	PSMParser* psm;
	std::string filename = argv[1];

	plf = new PLF(filename);
	psm = new PSMParser();
	psm->parse(filename.substr(0, filename.size() - 4) + ".psm");

	write_header(plf);
	write_global(plf);
	write_startpos(plf);
	write_background(plf);
	write_actions(plf);

	write_entrances(plf);
	write_exits(plf);
	write_hotspots(plf);
	write_liquid(plf);
	write_traps(plf);
      
	write_groundpieces(psm);

	write_footer(plf);

	delete plf;
	delete psm;
      }

      catch (PingusError err) {
	std::cout << "PingusError: " << err.message << std::endl;
      }
    }
}

/* EOF */
